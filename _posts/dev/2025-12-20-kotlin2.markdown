---
layout: content-layout
title: "코루틴 간단하게 알아보기!🤤"
date: 2025-12-20
categories: [DEV]
tags: [DEV, kotlin, 코틀린]
---

## 안녕하십니까! 😀

인프런 강의를 통해 배운 코틀린을 정리했습니다!

인프런 강좌명: 
[2시간으로 끝내는 코루틴](https://www.inflearn.com/course/2%EC%8B%9C%EA%B0%84%EC%9C%BC%EB%A1%9C-%EB%81%9D%EB%82%B4%EB%8A%94-%EC%BD%94%EB%A3%A8%ED%8B%B4/dashboard)

---

### 코루틴 빌더와 Job
#### 기본 예제
```
fun main() {
    runBlocking {
        printWithThread("START")
        launch {
            delay(2_000L)
            printWithThread("LAUNCH END")
        }
    }

    printWithThread("END") // END가 출력되려면 runBlocking이 종료될 때 실행
}
```
#### launch
코루틴을 제어할 수 있는 객체 Job을 반환 받는다.
```
fun main(): Unit = runBlocking {
    val job = launch(start = CoroutineStart.LAZY) {
        printWithThread("Hello launch")
    }

    delay(1_000L)
    job.start()
}
```
#### async
launch와 다르게 주어진 함수의 실행 결과를 반환할 수 있다.
```
fun main(): Unit = runBlocking {
    val job = async {
        3 + 5
    }
    val eight = job.await() // await : 여러 API를 동시에 호출하여 소요시간을 최소화 할 수 있다.
}
```
#### 코루틴의 취소
여러 코루틴을 사용할 때 코루틴을 적절히 취소해 컴퓨터 자원을 아껴야 한다!
취소에 협조하는 방법
- suspend 함수로 사용해야 취소가 가능하다! (delay 같은)
- Dispatchers.Defalut 다른 스레드에 launch를 배정
- isActve로 CancellationException을 던져서 취소시킬 수 있다.
#### 코루틴의 예외 처리와 Job의 상태 변화
각각이 root 코루틴이다.
```
var job = CoroutineScope(Dispatchers.Default).async {
    throw IllegalArgumentException()
}

job.await() // 써야만 예외를 출력하게 됨, launch를 쓰게 되면 바로 익셉션 출력
```
자식 코루틴의 예외를 부모에게 전파하고 싶지 않다면?

-> SupervisorJob()을 사용한다.

예외를 다루는 방법
- 직관적인 try - catch - finally
- CoroutineExceptionHandler 예외 발생 이후 에러 로깅 / 에러 메시지 전송 등에 활용
```
val exceptionHandler = CoroutineExceptionHandler { _, _ -> printWithThread("예외")}
```
- CoroutineExceptionHandler은 launch에만 적용 가능하고 부모 코루틴이 있으면 적용이 안된다.
#### Structured Concurrency
- 부모-자식 관계의 코루틴이 한 몸 처럼 움직이는 것
- 수많은 코루틴이 유실되거나 누수되지 않도록 보장
- 코드 내에 에러가 유실되지 않도록 적절히 보고될 수 있도록 보장
#### CoroutineScope와 CoroutineContext
- launch나 async는 CoroutineScope는 확장함수이다.
- runBlocking이 코루틴과 루틴의 세계를 이어주며 CoroutineScope를 사용했다. runBlocking이 필요하지 않게 된다.
```
val job = CoroutineScope(Dispatchers.Default).launch {

}

job.join()
```
- CoroutineScope의 역할은 CoroutineContext의 데이터를 보관하는 것
- CoroutineContext는 여러가지 코루틴 데이터를 갖고 있다.
- CoroutineContext는 Map과 Set을 합쳐놓은 형태
- CoroutineDispatcher
  - Dispatchers.Default
  - Dispatchers.IO
  - Dispatchers.Main
  - ExcutorService를 디스패처로 활용
#### suspending function
- suspend가 붙은 함수
- 정지 / 중지 / 유예와 같은 의미
- 코루틴이 중지 되었다가 재개될 수 있는 지점
- 여러 비동기 라이브러리를 사용할 수 있도록 도와준다
- 몇 가지 suspend 함수
  - coroutineScope 추가적인 코루틴을 만들고, 주어진 함수 블록이 바로 실행된다.
  - withContext은 coroutineScope과 동일한데 Dispatchers를 변경하고 싶을 때 사용한다.
  - withTimeout / withTimeoutOrNull 주어진 시간 안에 새로 생긴 코루틴이 완료되어야 하며 완료되지 않으면 예외를 던진다.
#### 코루틴과 Continuation
- 핵심은 Continuation을 전달하며 Callback으로 활용한다.
- Continuation을 왔다갔다 전달한다.
- Continuation Passing Style (CPS) 코루틴이 내부적으로 동작하는 원리
#### 코루틴과 활용과 마무리
- callback hell을 해결
- Kotlin 언어 키워드가 아닌 라이브러리의 기능
- Client UI 렌더링에 활용
- Server 여러 API를 동시에 호출
- Webflux 프레임워크
- 동시성 테스트

---

다음에는 다른 것으로 돌아오겠습니다!

긴 글 봐주셔서 감사합니다! 😌