<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>멍때리고 봐도 보이는 기술 블로그</title>
    <link rel="stylesheet" href="/assets/css/style.css">
</head>
<body>
    
<header>
    <h2>😵‍💫멍때리고😵‍💫 봐도 보이는 기술 블로그✍️</h2>

    <nav>
      <ul>
        
        
        
          <li>
            
              
              <span><a href="/">HOME</a></span>
              
            
          </li>
        
        
        
          <li>
            
              <span><a href="/DEV/">DEV (9)</a></span>
              <ul>
                
                  
                  
                  <li><a href="/DEV/블로그/">블로그 (4)</a></li>
                
                  
                  
                  <li><a href="/DEV/디자인패턴/">디자인패턴 (5)</a></li>
                
              </ul>
            
          </li>
        
        
        
          <li>
            
              
              <span><a href="/DB/">DB (0)</a></span>
              
            
          </li>
        
        
        
          <li>
            
              
              <span><a href="/INFRA/">INFRA (0)</a></span>
              
            
          </li>
        
        
        
          <li>
            
              
              <span><a href="/NEWS/">NEWS (0)</a></span>
              
            
          </li>
        
      </ul>
    </nav>
</header>

    <main>
    <div class="content-title">
        <h3>느슨한 결합의 핵심! 팩토리 패턴 알아보기! 🏭</h3>
    </div>
    <div class="content-body">
        <h2 id="디자인-패턴-분석-목차">디자인 패턴 분석 목차</h2>

<blockquote>
  <p>1: <a href="/dev/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/2025/02/27/design1.html">디자인 패턴 익혀두기! 첫 번째는 머리 잘 써야하는 전략 패턴! 🧐</a></p>
</blockquote>

<blockquote>
  <p>2: <a href="/dev/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/2025/03/01/design2.html">객체들에게 연락돌리는 옵저버 패턴! 📞</a></p>
</blockquote>

<blockquote>
  <p>3: <a href="/dev/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/2025/03/03/design3.html">여러 겹으로 메이크업 가능한 데코레이터 패턴 알아보기! 💄</a></p>
</blockquote>

<blockquote>
  <p>4: <a href="/dev/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/2025/03/08/design4.html">느슨한 결합의 핵심! 팩토리 패턴 알아보기! 🏭</a></p>
</blockquote>

<blockquote>
  <p>5: <a href="/dev/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/2025/03/10/design5.html">단순한 것 같지만 헤깔리는 싱글턴 패턴 알아보기! 👤</a></p>
</blockquote>

<h2 id="참고-서적">참고 서적</h2>

<p><a href="https://product.kyobobook.co.kr/detail/S000001810483">헤드퍼스트 디자인패턴</a></p>

<hr />

<h2 id="안녕하십니까-">안녕하십니까! 😀</h2>

<p>이번엔 4번째로 배우는 패턴은… 바로… 팩토리 패턴입니다!</p>

<p>대학생 시절부터 팩토리는 디자인 패턴 중 가장 기억에 남았던 거 같아요.</p>

<p>지금은 어떻게 썼는지 기억이 안나네요…</p>

<p>책을 보며 차근차근 파악해 봅시다!</p>

<hr />

<p>옵저버 패턴을 배울 때 느슨한 결합에 대해 들어보셨을겁니다!</p>

<p><strong>관계가 느슨하면 유지보수성이 올라가 코드를 쉽게 수리할 수 있죠!</strong></p>

<p>보통 객체를 생성할 때 다음과 같이 생성하게 됩니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Duck duck = new MallardDuck();
</code></pre></div></div>

<p>굳이 다른 클래스에 저렇게 선언을 해서 사용하진 않죠…</p>

<p>팩토리 패턴은 굳이 저걸 다른 클래스에서 생성하여 사용합니다!</p>

<p>지금은 왜 굳이 귀찮게…🥴 라는 생각이 지배적일겁니다.</p>

<p>귀찮지만 해놓으면 팩토리 패턴의 진가가 발휘되는 케이스가 있더라구요.</p>

<p>책에서는 new 연산자에 대해 다음과 같이 이야기하고 있습니다.</p>

<p><code class="language-plaintext highlighter-rouge">new 연산자를 바로 사용하는 것은 변경에 닫혀 있는 코드이고 확장성을 배제한 코드이다.</code></p>

<p>확장에 열려 있게 하려면 팩토리 패턴을 도입해보면 됩니다…!</p>

<p>말이 길어졌습니다… 🤐</p>

<p>팩토리 패턴은 크게 3가지로 나뉘는 데 차근 차근 한 번 보시죠… 😵‍💫</p>

<hr />

<h3 id="심플-팩토리-패턴">심플 팩토리 패턴</h3>

<p>심플 팩토리 패턴은 굉장히 간단한 팩토리 패턴이니 코드보면 바로 이해하기 쉬우실 겁니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public Pizza createPizza(String type) {
    Pizza pizza = null;

    if(type.equals("cheese")) {
        pizza = new CheesePizza();
    } else if(type.equals("pepperoni")) {
        pizza = new PepperoniPizza();
    }
}
</code></pre></div></div>

<p>위처럼 파라미터에 의해 Pizza를 맞춤형 하위 클래스로 생성하도록 구성하였습니다.</p>

<p>아까 언급한 느슨한 결합으로 인해 어떤 피자를 생성할지에 대한 유동적인 생성이 가능한 것이죠…!</p>

<p>🚨 <span style="color: red;">이건 아주 심플하니 쉬운 패턴인데 이제 다음 팩토리부터 모르시는 분들은 조금 머리 아프니 주의하세요…</span> 🥶</p>

<h3 id="팩토리-메소드-패턴">팩토리 메소드 패턴</h3>

<p>클래스 자체에서 팩토리 생성하는 건 알아봤으니 이제는 메소드로 생성하는 방법도 알아보셔야 합니다!</p>

<p>책에 나온 피자 가게를 토대로 우선 클래스 다이어그램을 보겠습니다.</p>

<p><img src="https://i.imgur.com/IGwILgC.png" alt="Imgur" /></p>

<p>피자 가게에 두 가지 유형의 피자 가게를 둔 예시입니다.</p>

<p>아까처럼 상위 클래스에서 단순 팩토리 패턴을 쓰면 될까싶지만… 추가 요건이 있습니다.</p>

<p>뉴욕 피자 가게는 뉴욕 스타일의 피자 4가지를 만들어야 하고…</p>

<p>시카고 피자 가게는 시카고 스타일의 피자 4가지를 만들어야 한답니다… 😰</p>

<p>기존처럼 createPizza 메소드에서 처리하기에는 유형이 훨씬 더 늘어난거죠…!</p>

<p>그래서 위처럼 일단 뉴욕 스타일과 시카고 스타일로 캡슐화를 우선 진행했고 아래처럼 생성 메소드를 구현했습니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class NYPizzaStore extends PizzaStore {

	Pizza createPizza(String item) {
		if (item.equals("cheese")) {
			return new NYStyleCheesePizza();
		} else if (item.equals("veggie")) {
			return new NYStyleVeggiePizza();
		} else if (item.equals("clam")) {
			return new NYStyleClamPizza();
		} else if (item.equals("pepperoni")) {
			return new NYStylePepperoniPizza();
		} else return null;
	}
}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class ChicagoPizzaStore extends PizzaStore {

	Pizza createPizza(String item) {
        	if (item.equals("cheese")) {
            		return new ChicagoStyleCheesePizza();
        	} else if (item.equals("veggie")) {
        	    	return new ChicagoStyleVeggiePizza();
        	} else if (item.equals("clam")) {
        	    	return new ChicagoStyleClamPizza();
        	} else if (item.equals("pepperoni")) {
            		return new ChicagoStylePepperoniPizza();
        	} else return null;
	}
}
</code></pre></div></div>

<p>그리고 상위 클래스인 PizzaStore는 다음과 같은 구현되어 있죠.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public abstract class PizzaStore {
 
	abstract Pizza createPizza(String item);
 
	public Pizza orderPizza(String type) {
		Pizza pizza = createPizza(type);
		System.out.println("--- Making a " + pizza.getName() + " ---");
		pizza.prepare();
		pizza.bake();
		pizza.cut();
		pizza.box();
		return pizza;
	}
}
</code></pre></div></div>

<p>위처럼 팩토리 메소드 패턴은 객체를 생설할 때 필요한 인터페이스(추상 클래스)를 만들고 <span style="background-color:rgb(200, 200, 255);"><strong>어떤 클래스의 인스턴스를 만들지는 서브 클래스에서 결정</strong></span>하는 구조입니다.</p>

<p>참고로 저는 아직까지도 왜 팩토리 메소드 패턴과 명확하게 다른 점을 모르겠습니다.</p>

<p>그래서 차이점을 더 파보았더니 다음과 같은 내용이 있더군요.</p>

<p><span style="color: red;">팩토리 메소드 패턴은 재사용을 할 수 있도록 일반적인 프레임워크를 제공할 수 있다.</span></p>

<p>무슨 뜻이냐…</p>

<p>createPizza만 있는 단순 팩토리 패턴의 PizzaStore를 호출한다고 했을 때.. 호출부에서 생성된 피자로 여러 가지 코드 구현을 해야 합니다.</p>

<p>만약 처리 로직이 동일한 부분을 여러 번 호출해야 한다면 PizzaStore에 재사용 가능한 orderPizza 메소드를 만들어서 orderPizza만 호출하면 될 듯 합니다.</p>

<p>슈퍼 클래스가 처리를 하는 메소드가 생겼으니 생성은 밑에 서브 클래스 친구들한테 맡기는 구조가 된겁니다.</p>

<p>결론은… <span style="color: red;">재사용할 수 있는 메소드를 구현함으로써 생성부를 서브 클래스로 캡슐화하여 팩토리를 구현한다…</span>라고 보심 될 것 같습니다.</p>

<p>여기서 끝이 아닙니다…</p>

<p>한가지 끝판왕 팩토리 패턴이 또 있어요… 😭 <del>(집에 가고 싶다…)</del></p>

<h3 id="추상-팩토리-패턴">추상 팩토리 패턴</h3>

<p>아까 추상화했는데 또 추상 나오니…?</p>

<p>뭐가 다를까… 막막할 수 있습니다…</p>

<p>그전에 알아두면 좋은 용어 한 번 보고 가시죠…</p>

<p>✏️ <span style="color: red;">의존성 뒤집기 원칙이란? 추상화된 것에 의존하게 만들고 구상 클래스에 의존하지 않게 만든다.</span></p>

<p><del>(대체 무슨 소리래… 🦴)</del></p>

<p><strong>어려운 김에 어려운 말 조금 더 나갑니다…</strong></p>

<blockquote>
  <p>의존성 뒤집기 원칙을 지키는 방법</p>
</blockquote>

<ol>
  <li>
    <p>변수에 구상 클래스의 레퍼런스를 저장하지 맙시다.</p>
  </li>
  <li>
    <p>구상 클래스에서 유도된 클래스를 만들지 맙시다.</p>
  </li>
  <li>
    <p>베이스 클래스에 이미 구현되어 있는 메소드를 오버라이드하지 맙시다.</p>
  </li>
</ol>

<p>위의 내용이 이해가 안되신다면.. 추상 팩토리 패턴에 녹여들어간 원칙이라고 보심 될 것 같습니다.</p>

<p><strong>위 두 가지 패턴보다 난이도가 1.5배정도 올라가니 한 번 잘 살펴보십시다…</strong></p>

<p>일단 예시에서 변경된 Pizza 클래스부터 보겠습니다.</p>

<p>AS-IS</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public abstract class Pizza {
	String name;
	String dough;
	String sauce;
	ArrayList&lt;String&gt; toppings = new ArrayList&lt;String&gt;();
 
	void prepare() {
		System.out.println("Prepare " + name);
		System.out.println("Tossing dough...");
		System.out.println("Adding sauce...");
		System.out.println("Adding toppings: ");
		for (String topping : toppings) {
			System.out.println("   " + topping);
		}
	}
  
	// 이하 생략
}
</code></pre></div></div>

<p>TO-BE</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public abstract class Pizza {
	String name;

	Dough dough;
	Sauce sauce;
	Veggies veggies[];
	Cheese cheese;
	Pepperoni pepperoni;
	Clams clam;

	abstract void prepare();

    // 이하 생략
}
</code></pre></div></div>

<p>Pizza 재료를 처리하는 prepare 메소드가 추상화로 변신을 일단 했습니다.</p>

<p>그 다음 prepare를 구현하는 하위 클래스를 한 번 보겠습니다.</p>

<p>AS-IS (피자 종류별로 클래스를 만들어서 처리했음)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class NYStyleCheesePizza extends Pizza {

	public NYStyleCheesePizza() { 
		name = "NY Style Sauce and Cheese Pizza";
		dough = "Thin Crust Dough";
		sauce = "Marinara Sauce";
 
		toppings.add("Grated Reggiano Cheese");
	}
}
</code></pre></div></div>

<p>TO-BE (피자의 주 원재료별로 클래스를 만들어서 처리했음)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class CheesePizza extends Pizza {
	PizzaIngredientFactory ingredientFactory;
 
	public CheesePizza(PizzaIngredientFactory ingredientFactory) {
		this.ingredientFactory = ingredientFactory;
	}
 
	void prepare() {
		System.out.println("Preparing " + name);
		dough = ingredientFactory.createDough();
		sauce = ingredientFactory.createSauce();
		cheese = ingredientFactory.createCheese();
	}
}
</code></pre></div></div>

<p>가장 크게 바뀐 점은 기존 피자 클래스에서는 속성을 지정하여 반환하고 끝이었습니다.</p>

<p>이제는 피자 클래스에 새로운 팩토리 클래스가 변수로 가지고 있음을 알 수 있습니다.</p>

<p>상황에 따라 변칙적인 치즈 피자로 만들 수 있겠군요. (확장성 업그레이드 완료)</p>

<p>그럼 아까 구현한 createPizza 메소드는 어떻게 바뀌는 걸까요?</p>

<p>뉴욕 스타일의 피자 가게 클래스를 한 번 살펴보시죠.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class NYPizzaStore extends PizzaStore {
 
	protected Pizza createPizza(String item) {
		Pizza pizza = null;
		PizzaIngredientFactory ingredientFactory = 
			new NYPizzaIngredientFactory();
 
		if (item.equals("cheese")) {
  
			pizza = new CheesePizza(ingredientFactory);
			pizza.setName("New York Style Cheese Pizza");
  
		} else if (item.equals("veggie")) {
 
			pizza = new VeggiePizza(ingredientFactory);
			pizza.setName("New York Style Veggie Pizza");
 
		} else if (item.equals("clam")) {
 
			pizza = new ClamPizza(ingredientFactory);
			pizza.setName("New York Style Clam Pizza");
 
		} else if (item.equals("pepperoni")) {

			pizza = new PepperoniPizza(ingredientFactory);
			pizza.setName("New York Style Pepperoni Pizza");
 
		} 
		return pizza;
	}
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">PizzaIngredientFactory ingredientFactory =	new NYPizzaIngredientFactory();</code> 이 부분이 보이시나요!?</p>

<p>원재료를 생성하는 클래스를 생성하여 가지고 있고 피자를 만들 때 이 팩토리 클래스를 인자로 넘겨주고 있습니다!</p>

<p>마지막으로 새로 생긴 PizzaIngredientFactory 이 팩토리와 이를 구현하고 있는 NYPizzaIngredientFactory 이 클래스를 한 번 살펴보시죠.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public interface PizzaIngredientFactory {
 
	public Dough createDough();
	public Sauce createSauce();
	public Cheese createCheese();
	public Veggies[] createVeggies();
	public Pepperoni createPepperoni();
	public Clams createClam();
 
}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class NYPizzaIngredientFactory implements PizzaIngredientFactory {
 
	public Dough createDough() {
		return new ThinCrustDough();
	}
 
	public Sauce createSauce() {
		return new MarinaraSauce();
	}
 
	public Cheese createCheese() {
		return new ReggianoCheese();
	}
 
	public Veggies[] createVeggies() {
		Veggies veggies[] = { new Garlic(), new Onion(), new Mushroom(), new RedPepper() };
		return veggies;
	}
 
	public Pepperoni createPepperoni() {
		return new SlicedPepperoni();
	}

	public Clams createClam() {
		return new FreshClams();
	}
}
</code></pre></div></div>

<p>위에 보시는 것처럼 뉴욕 스타일에 맞는 소스, 치즈, 야채 등을 리턴하고 있음을 알 수 있습니다.</p>

<p>아마 저보다 이해력 좋으신 분들은 예제만 보고도 추상 팩토리 패턴과 팩토리 메소드 패턴의 차이점이 뭔지 이해되실 겁니다.</p>

<p>저는 여러 번의 이해와 노력 끝에 파악을 조금 했답니다… 😮‍💨</p>

<p>우선 추상 팩토리 패턴은 <span style="background-color:rgb(200, 200, 255);"><strong>구상 클래스에 의존하지 않고도 서로 연관되거나 의존적인 객체로 이루어진 제품군을 생산하는 인터페이스를 제공</strong></span>합니다.</p>

<p>아까 예제에 나왔던 PizzaIngredientFactory 클래스가 핵심 역할이라고 할 수 있죠.</p>

<p>느낌만 한 번 말씀드리면</p>

<p>이전에 팩토리 메소드 패턴은 뭔가 PizzaStore 서브 클래스에서 직접 피자를 생산하여 고정된 재료로 만들었다고 치면</p>

<p>추상 팩토리 패턴은 이제 PizzaStore 서브 클래스 마저도 PizzaIngredientFactory한테 맡기고 재료도 그룹지어 종류별로 세분화하게 관리되는 느낌입니다.</p>

<h3 id="여기서-잠깐-추상-팩토리-패턴의-장단점을-알아보자-출처-gpt">여기서 잠깐!!! 추상 팩토리 패턴의 장단점을 알아보자! (출처: GPT)</h3>

<table>
  <thead>
    <tr>
      <th>장점</th>
      <th>단점</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>객체 생성 로직을 캡슐화하여 클라이언트 코드 변경 없이 확장 가능</td>
      <td>너무 많은 클래스 수 증가</td>
    </tr>
    <tr>
      <td>클라이언트 코드가 구체적인 클래스에 의존하지 않음 → 결합도 낮아짐</td>
      <td>새로운 개별 제품(예: 과일토핑 추가) 추가 시 인터페이스 및 서브 클래스 전부 변경 필요</td>
    </tr>
  </tbody>
</table>

<h3 id="추상-팩토리-패턴과-팩토리-메소드-패턴의-차이점-확인하기-출처-gpt">추상 팩토리 패턴과 팩토리 메소드 패턴의 차이점 확인하기! (출처: GPT)</h3>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>팩토리 메소드 패턴</th>
      <th>추상 팩토리 패턴</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>초점</td>
      <td>단일 객체의 생성을 캡슐화</td>
      <td>관련된 여러 객체를 그룹으로 생성</td>
    </tr>
    <tr>
      <td>확장성</td>
      <td>새로운 객체 유형 추가 가능 (클래스 상속 활용)</td>
      <td>새로운 제품군 추가 가능 (팩토리 인터페이스 확장)</td>
    </tr>
    <tr>
      <td>코드 복잡도</td>
      <td>비교적 간단</td>
      <td>상대적으로 복잡</td>
    </tr>
    <tr>
      <td>유지보수성</td>
      <td>특정 객체에 대한 변경에 유리</td>
      <td>여러 객체의 일관성을 유지하기 좋음</td>
    </tr>
    <tr>
      <td>사용 사례</td>
      <td>객체 생성을 위임하여 유연성을 확보하고 싶을 때</td>
      <td>제품군 전체를 일관되게 관리해야 할 때</td>
    </tr>
  </tbody>
</table>

<h3 id="팩토리-메소드-패턴을-사용한-예시">팩토리 메소드 패턴을 사용한 예시</h3>

<ol>
  <li>
    <p>특정 타입의 데이터베이스 커넥션(MySQLConnection, PostgreSQLConnection)을 생성하는 경우</p>
  </li>
  <li>
    <p>특정 형태의 문서(PDFDocument, WordDocument)를 생성하는 경우</p>
  </li>
</ol>

<h3 id="추상-팩토리-패턴을-사용한-예시">추상 팩토리 패턴을 사용한 예시</h3>

<ol>
  <li>
    <p>GUI 라이브러리에서 Windows/MacOS UI 컴포넌트(Button, Checkbox, TextField 등)를 통일성 있게 생성하는 경우</p>
  </li>
  <li>
    <p>게임에서 서로 다른 종족(예: 엘프, 오크)의 유닛(Warrior, Archer, Mage 등)을 생성하는 경우</p>
  </li>
</ol>

<h3 id="결론">결론</h3>

<p>디자인 패턴을 무조건 쓴다고 해서 좋은 건 아니구나라는 것을 팩토리 패턴에게 좀 느꼈습니다.. <del>(물론 이해하기 어려워서 안쓰고 싶은 생각도 있습니다.)</del></p>

<hr />

<p>다음에는 혼자가 좋은… 싱글턴 패턴을 뜯어봅시다!</p>

<h1 id="긴-글-봐주셔서-감사합니다-">긴 글 봐주셔서 감사합니다! 😌</h1>

    </div>

    
        <div class="tags">
            
            <span>#디자인패턴</span>
            
            <span>#Design pattern</span>
            
            <span>#헤드퍼스트</span>
            
            <span>#GoF</span>
            
            <span>#팩토리 패턴</span>
            
            <span>#Factory Pattern</span>
            
        </div>
    
    
    <!-- 댓글 영역 -->
    <div class="comments">
        <script src="https://utteranc.es/client.js"
            repo="graves85/graves85.github.io"
            issue-term="pathname"
            label="comment"
            theme="github-light"
            crossorigin="anonymous"
            async>
        </script>
    </div>
    </main>

    <footer>
    © 2025 Tech Insights | Powered by Graves85
</footer>
</body>
</html>
